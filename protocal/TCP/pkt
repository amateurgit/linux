TCP 报文

    ----------------------------------------------------------------------------------------------
    |                      sport                       |                    dport                   |
     -----------------------------------------------------------------------------------------------
    |                                               seq num                                         |
     -----------------------------------------------------------------------------------------------
    |                                               ack num                                         |
     -----------------------------------------------------------------------------------------------
    | offset |  reserved |  URG ACK PSH RST SYN FIN    |                 window size                |
     -----------------------------------------------------------------------------------------------
    |                    checksum                      |                 urgent pointer             |
     -----------------------------------------------------------------------------------------------
    |                                               tcp options                                     |
     -----------------------------------------------------------------------------------------------

    sport
        源端口
    dport
        目的端口

    /* 
       seq 与 ack 联合使用
           TCP 对发送的每个字节都会编号
     */
        seq
            4 bytes, 发送的数据第一个字节的编号
        ack
            4 bytes, 期望收到对方下次发送的数据的第一个字节编号
            ACK 标记为 1 时有效
    /***************************end**********************************/

    offset
        4 bits, 用户数据相对 TCP 首部的偏移, 即 TCP 首部的长度。首部最大长度 60 bytes.

    reserved
        6 bits

    URG
        1 bit, 值为 1 时, 用户数据的 "urgent pointer" 字节优先发送
    ACK
        1 bit, 值为 1 时, ack 有效
    PSH
        1 bit, 值为 1 时, 接收到报文的主机会尽快将数据交给应用程序, 不会等到缓存满了再交付
    RST
        1 bit, 值为 1 时, 通信出现故障, 关闭连接
    SYN
        1 bit, 值为 1 时, 期望与对方建立连接
    FIN
        1 bit, 值为 1 时, 释放连接

    window   /* 每发送一次数据, 都需要一次确认应答。为提高通信效率, 设计了 win 字段, 采用累计确认机制  */
      窗口大小。即 无需等待确认应答，而可以继续发送数据的最大值, 由接收方确定。




三次握手 与 四次挥手

    第一次握手

                  SYN, seq = x
       Client ---------------------> Server 
     (SYN_SENT)                    (SYN_RECV)  

    第二次握手

                  ACK, ack = x + 1, SYN, seq = y
       Server -------------------------------------> Client
     (SYN_RECV)                                   (ESTABLISHED)

    第三次握手

                  ACK, ack = y + 1
       Client -----------------------> Server
     (ESTABLISHED)                 (ESTABLISHED)

    ...

    第一次挥手

                  FIN, seq = u
       Client -----------------------> Server
      (FIN-WAIT-1)                   (CLOSE-WAIT)

    第二次挥手

                       ACK, ack = u + 1
       Server -------------------------------------> Client
     (CLOSE-WAIT)                                   (FIN-WAIT-2)

    第三次挥手

                  FIN, seq = v
       Server -----------------------> Client
      (LAST-ACK)                   (TIME-WAIT)


    第四次挥手

                       ACK, ack = u + 1
       Client -------------------------------------> Server
     (TIME-WAIT)                                   (CLOSED)
          |
          | 2MSL  若 ACK 报文丢失, Server 超时重传 FIN, Client 重新启动 2MSL 计时, 确保 Server 正确进入 CLOSED 状态 
          V
       (CLOSED)

 
附加

    RST 攻击

        RST - 异常关闭连接。

             1. A 向 B 发起连接, B 上未监听相应端口, B 操作系统 TCP 处理程序发送 RST包。

             2. A 和 B 正常通信, A 发送 FIN 关闭请求, B 发送 ACK 应答, 断网了..., 
                断网期间 A 重启进程丢弃了原连接..., 
                网络恢复, B 接着向 A 发送数据, A 发送 RST 包, B 收到后出现 "connect reset by peer" 错误

       攻击原理

           A 和 B 正常通信期间, C 伪装成 A 发送 RST 包, 导致 A 和 B 连接中断。

    SYN 攻击

        主机 B 在第二次握手之后, 等待 A 的确认包, 期间资源一直被占用。

        抓住这个时机, 主机 A 不断地给主机 B 发送大量 SYN 报文, 导致 B 资源耗尽。
