1. 内存缓存

    内核分配内存的函数 : kmalloc 和 kfree

    内存缓存 : 

	某些数据结构类型，需要频繁分配内存创建示例，为提高效率，采用内存缓存方案

    网络数据结构中，采用内存缓存方案的例子 : 

	套接字缓冲区描述符

	邻居协议映射

	路由表

    内存缓存相关的内核函数:

	kmem_cache_create	创建一个缓存

	kmem_cache_destroy	销毁一个缓存

	kmem_cache_malloc	分配一个缓冲

	kmem_cache_free		回收一个缓冲

2. 哈希表

    缓存通常用 hash 表实现

3. 引用计数

4. 垃圾回收

    异步

	这种回收机制的不依赖于特定的事件，会定时启动回收函数。

    同步

	内存不足时，立即触发垃圾收集

5. 函数指针和虚拟函数表

    结构中使用函数指针可以实现类似面向对象的编程效果

    虚拟函数表 : 指向一个数据结构的一组函数指针。比如 : L3 和 L4 之间的接口， 采用 VFT

6. goto 语句

7. 向量定义

	struct abc {
		int age;
		char *name[20];
		...
		char placeholder[0];	// 向量
	}

8. 条件指示指令

	#ifdef 及其系列指令

9. 条件检查的编译期间最优化

    内核代码中有很多使用 likely 和 unlikely 宏的地方， 这样的宏用在条件语句中。

    条件成立的可能性较大时使用 likely, 否则使用 unlikely，宏告诉 gcc 条件成立的可能性大小，gcc 对代码进行优化(比如合理安排代码顺序)，提高执行效率。

    err = do_something(x, y, z);
    if (err)
	handle_error(err);

    假设 do_something 很少失败，重写代码:

    err = do_something(x, y, z);
    if (unlikely(err))
        handle_error(err);


10. 互斥

    自旋锁

	锁在任一时刻只能被一个线程使用。

        线程试图获得一个正在执行的线程锁持有的锁，则要进行循环等待(忙等，而不是睡眠，会浪费 CPU 资源)。

    读写自旋锁

	读写自旋锁三种状态 : 读模式的加锁、写模式的加锁 和 不加锁。

	当读写锁是写枷锁状态时，在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞；

	当读写锁以读状态加锁时，所有试图以读模式对其加锁的线程都可以得到访问权，但是任何试图以写模式对其加锁的线程都会被阻塞；

	当读写锁处于读模式锁住状态，而这时有一个线程试图以写模式获取锁时，读写锁通常会阻塞随后的读模式写请求。

    RCU (READ-COPY-UPDATE)

        随意读，但更新数据的时候，需要先复制一份副本，在副本上完成修改，再一次性地替换旧数据。

	读时不需要同步机制，写时需要加锁机制。

11. 字节序

12. 捕捉 bug

13. 统计数据

14. 测量时间
